library("ParamHelpers")
library("ggplot2")
library("data.table")
library("GNArchitect")
library("magrittr")
library("ggbeeswarm")

optruns <- readRDS("data/optruns.rds")  # generated by collect_run_results.R

optruns$metainfo$walltime <- round(optruns$metainfo$walltime)  # these are not true integers because of log -> exp precision loss
optruns$metainfo$maxlen <- round(optruns$metainfo$maxlen)  # these are not true integers because of log -> exp precision loss

# all the wall time steps that were evaluated
walltimes <- unique(optruns$metainfo$walltime)

# the batchsize is also a property of the model we want to record.
optruns$optpath.x.transformed$batchsize <- optruns$metainfo$batchsize
optruns$optpath.x$batchsize <- log(optruns$metainfo$batchsize)
optruns$optpath.x$model_type <- as.numeric(as.factor(optruns$optpath.x.transformed$model_type))
optruns$metainfo$batchsize <- NULL

# How many different levels are there, effectively, for each hyperparameter?
# We can not use `optpath.x` here, since some values are continuous for the optimizer
# but transformation then rounds the value.
numlevels <- vapply(optruns$optpath.x.transformed, function(x) {
  x <- x[!is.na(x)]
  length(unique(x))
}, numeric(1))


params.nonparams <- c("runid", "num_targets")  # meta-info hyperparameters that are not interesting for analysis
params.params <- setdiff(names(numlevels), params.nonparams)  # names of all actual hyperparameters
params.continuous <- names(numlevels)[numlevels > 20] %>% setdiff(params.nonparams)
params.binary <- names(numlevels)[numlevels == 2] %>% setdiff(params.nonparams)
params.discrete <- setdiff(names(numlevels), c(params.nonparams, params.continuous, params.binary))
params.untransformed <- Map(identical, optruns$optpath.x[, params.continuous, with = FALSE], optruns$optpath.x.transformed[, params.continuous, with = FALSE]) %>%
  Filter(f = identity) %>% names

# items for which we are interested in the respective maxima: i.e. best y for all walltimes, both maxlens, both model types.
splitby <- c("maxlen", "walltime", "model_type")

#####################################
# Creating Table of Best Performers #
#####################################

# get a median / mode value for x.
# For numeric values, get the median (round if integer), otherwise the mode.
consensus <- function(x) {
  if (is.integer(x)) return(round(median(x)))
  if (is.numeric(x)) return(median(x))
  if (is.logical(x)) return(as.logical((median(x))))  # this is the mode, since length(x) is odd
  if (all(is.na(x))) return(x[[1]])
  return(names(sort(-table(x)))[[1]])
}

getTopNTable <- function(topn) {
  alldata <- cbind(optruns$optpath.x.transformed, optruns$metainfo)
  alldata[by = splitby, .SDcols = setdiff(params.params, splitby), , {
    c(
      lapply(.SD[order(y, decreasing = TRUE)[seq_len(topn)]], consensus),
      list(desc = sprintf("median-of-%s_%shr_%s_len_%s", topn, walltime / 3600, model_type, maxlen))
    )
  }][, c(params.params, "desc"), with = FALSE]
}

# hyperparameters, together with performance y value, for each configuration
toptable <- cbind(optruns$optpath.x.transformed, optruns$metainfo)[, .SD[which.max(y)], by = splitby][, c(params.params, "y", "paramcount"), with = FALSE]
fwrite(toptable, "data/best_configs.csv")
fwrite(getTopNTable(3), "data/median_of_top_3.csv")
fwrite(getTopNTable(9), "data/median_of_top_9.csv")

#######################################
# Creating Performance Progress Plots #
#######################################

optruns$metainfo$model_type <- optruns$optpath.x.transformed$model_type

# make a copy of metainfo that contains NA-rows if cumwalltime is not present.
metainfo.complete <- optruns$metainfo[CJ(runid = unique(optruns$metainfo$runid), dob = unique(optruns$metainfo$dob)), on = c("dob", "runid")]
metainfo.complete[, walltime := max(walltime, na.rm = TRUE), by = "dob"]
metainfo.complete[, firstInDob := c(1, diff(dob)) > 0, by = "runid"]
metainfo.complete[firstInDob == TRUE, cumwalltime := cumsum(walltime), by = "runid"]
metainfo.complete[, cumwalltime := mean(cumwalltime, na.rm = TRUE) , by = c("runid", "dob")]
metainfo.complete[order(dob), cummax.y := cummax(y), by = "maxlen"]
metainfo.complete[, cummax.y := max(cummax.y), by = c("maxlen", "dob")]

which(!apply(is.na(metainfo.complete), 2, any))

plotProgress <- function(include.cummax = TRUE, include.evals = TRUE, maxlen = 150, maxtime = 20, plot.x = "dob", color.by = "model_type") {
  mxl <- maxlen
  data <- copy(metainfo.complete)[, walltime.hrs := walltime / 3600][, cumwalltime.hrs := cumwalltime / 3600][walltime.hrs <= maxtime & maxlen == mxl]

  plt <- ggplot(data[y > 0]) + theme_bw()
  if (include.evals) {
    plt <- plt + geom_point(aes(x = get(plot.x), y = y, color = as.factor(get(color.by))))
  }
  if (include.cummax) {
    cmdata <- rbind(
      data[unique(data[, .(dob = dob + 1, runid, cm2 = cummax.y)]), on = c("dob", "runid")][, c(plot.x, "cm2"), with = FALSE] %>% setnames("cm2", "cummax.y"),
      data[, c(plot.x, "cummax.y"), with = FALSE]
    ) %>% unique
    plt <- plt + geom_line(data = cmdata, aes(x = get(plot.x), y = cummax.y))
  }
  plt
}


plotProgress(color.by = "walltime.hrs")
plotProgress(maxtime = 6, color.by = "walltime.hrs")
plotProgress(color.by = "walltime.hrs", plot.x = "cumwalltime.hrs")
plotProgress(maxtime = 6, color.by = "walltime.hrs", plot.x= "cumwalltime.hrs")
plotProgress(color.by = "walltime.hrs", plot.x = "cumwalltime.hrs") + scale_x_log10(limits = c(1, 1000))
plotProgress(maxtime = 6, color.by = "walltime.hrs", plot.x = "cumwalltime.hrs") + scale_x_log10(limits = c(1, 400))

plotProgress(maxlen = 10000, color.by = "walltime.hrs")
plotProgress(maxlen = 10000, maxtime = 6, color.by = "walltime.hrs")
plotProgress(maxlen = 10000, color.by = "walltime.hrs", plot.x = "cumwalltime.hrs")
plotProgress(maxlen = 10000, maxtime = 6, color.by = "walltime.hrs", plot.x= "cumwalltime.hrs")
plotProgress(maxlen = 10000, color.by = "walltime.hrs", plot.x = "cumwalltime.hrs") + scale_x_log10(limits = c(1, 1000))
plotProgress(maxlen = 10000, maxtime = 6, color.by = "walltime.hrs", plot.x = "cumwalltime.hrs") + scale_x_log10(limits = c(1, 400))

############################################
# Creating Beeswarm Plot of Top Performers #
############################################

analysing <- cbind(optruns$optpath.x, optruns$metainfo)
analysing <- analysing[walltime == 6 * 3600 & maxlen == 150]
analysing <- analysing[, colnames(analysing)[!duplicated(colnames(analysing))], with = FALSE]


lowerlimits <- lapply(optruns$paramsets, function(x) as.list(getLower(x))) %>% rbindlist(fill = TRUE) %>% apply(2, min, na.rm = TRUE)
upperlimits <- lapply(optruns$paramsets, function(x) as.list(getUpper(x))) %>% rbindlist(fill = TRUE) %>% apply(2, max, na.rm = TRUE)
lowerlimits$batchsize <- 0
upperlimits$batchsize <- log(8192)
lowerlimits$maxlen <- min(analysing$maxlen)
upperlimits$maxlen <- max(analysing$maxlen)
lowerlimits$model_type <- min(analysing$model_type)
upperlimits$model_type <- max(analysing$model_type)


# mapping untransformed values to their text names
namemaps.binary <- sapply(params.binary, function(pname) {
  if (!pname %in% colnames(optruns$optpath.x) || !pname %in% colnames(optruns$optpath.x.transformed)) {
    x <- cbind(optruns$optpath.x, optruns$optpath.x.transformed)[[pname]] %>% unique()
    return(data.table(value = x, name = as.character(x), key = "value"))
  }
  data.table(value = optruns$optpath.x[[pname]], name = as.character(optruns$optpath.x.transformed[[pname]])) %>% unique %>% setkeyv("value")
}, simplify = FALSE)

analysing[, pointid := seq_len(nrow(analysing))]

analysing[, yrank := rank(-y), by = c("walltime", "maxlen")]
analysing[, yperc := yrank / length(y), by = c("walltime", "maxlen")]

analysing[order(yperc)]

suppressWarnings(analysing.transposed <- melt(analysing, id.vars = "pointid", measure.vars = params.params))


analysing.transposed[analysing, model_type := namemaps.binary$model_type[model_type, name], on = "pointid"]

analysing.transposed[, tier := "all"]


for (transforming in intersect(names(lowerlimits), params.params)) {
  analysing.transposed[variable == transforming,
    value := (value - lowerlimits[[transforming]]) / (upperlimits[[transforming]] - lowerlimits[[transforming]])
  ]
}

plotting <- rbind(analysing.transposed, copy(analysing.transposed)[pointid %in% analysing[yperc <= 0.1, pointid]][, tier := "top10percent"])
plotting$tier <- as.factor(plotting$tier)

ggplot() +
  geom_quasirandom(data = plotting[variable %in% params.continuous], aes(x = variable, y = value, alpha = tier), dodge.width = .8, color = "red") +
  geom_point(data = plotting[variable %in% params.continuous & pointid %in% analysing[yrank == 1, pointid] & tier == "top10percent"],
    aes(x = variable, y = value, alpha = tier), position = position_nudge(x = .2), size = 5) +
  theme_bw() + theme(axis.text.x = element_text(angle = 90))




